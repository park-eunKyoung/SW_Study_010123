<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      const numbers = [1, 2, 3, 4];
      const fruits = ['Apple', 'Banana', 'Cherry'];
      //map을 이용해서 numbers 배열에서 3보다 작으면 true 그렇지
      //않으면 false반환
      //mapping : 1:1대응

    //   const array = numbers.map((number)=>{
    //          console.log([number< 3]);
    //      })

    // const a = numbers.map((number)=>{
    //   return number<3;  
    // });
        // const a=numbers.map(number=> number<3);
        // console.log(a);

      //ArrayList<Member>
      const memberList=[
        {name:'Lee',age:23,login:true},
        {name:'Hong',age:23,login:true},
        {name:'Choi',age:30,login:false}
      ];  //{ }= new object
      //문제> 회원이름만 배열로 저장해서 출력
     
        let data=[];
        memberList.forEach((member,idx)=>{
          // data[idx]=member.name;
          data.push(member.name)
        });

      // const data=memberList.map(member=>{
      //   return member.name;
      // });
       //console.log(data);
      
      //.filter():filter 메소드의 콜백함수가 요소 갯수만큼 실행후
      //만족하는 요소를 배열로 반환
      //문제> 나이가 23살인 회원만 배열로 저장 후 출력
        let data2=[];
        memberList.forEach(member => {
          if (member.age===23) {
            data.push(member)
          }
        });

      //  const data=memberList.filter(member=>{
      //     return member.age===23;
      //   })

       // console.log(data2);
        //문제> 이름이 L로 시작하는 멤버 검색
        //let data=[];
        const data3= memberList.filter(member=>{
         return member.name.startsWith('L');
         // return /^L/.test(member.name);
        })
       // console.log(data3);

       //some:배열에 조건을 만족하는 요소가 1개이상이면 true를 반환
       const data4=memberList.some(item=>{
        return item.login===true;
       })
       // console.log(data4);
        
       //every : 배열에 조건에 만족하는 요소가 전부라면 true를 반환
       const data5=memberList.every(elem=>{
        return elem.login===true;
       });
       //console.log(data5);
       
       //find : 배열에서 조건에 만족하는 첫째요소를 반환
       const data6=memberList.find(elem=>{
        return elem.age===23;
       })
       //console.log(data6);

       //findIndex : 배열에서 조건에 만족하는 첫째 요소의 인덱스를 반환
       const data7=memberList.findIndex(elem=>{
        return elem.age===30;
       })
       //console.log(data7);

       //.include(): 배열요소에 특정값이 포함되면 true 아니면 false 반환
       const data8=fruits.includes('Apple');
       //console.log(data8);
       
       //.slice(startIndex, endIndex):startIndex 부터 endIndex 미만까지의
       //배열을 생성하여 반환(많이 안쓰는 듯)
      function sliceEx(){
        let newArr=numbers.slice(1,3); //idx:1~2까지
        //console.log(newArr); 

        //시작인덱스부터 끝까지
        newArr=numbers.slice(1);
       // console.log(newArr);
      }
      sliceEx();
      //console.log(numbers);  // 원본 배열에는 변화가 없음 , 카피본을 잘라서 출력
      
      //.push : 배열의 가장뒤쪽부터 데이터 삽입(아주 중요, 편리) 
      //아래에서 부터 차곡차곡 쌓이는 배열 stack, push로 데이터 저장(a,b,c) , 
      //pop으로 데이터 삭제(c,b,a)
      //원본배열 수정됨(주의)
      //numbers[4]=5
      //numbers[5]=6
      numbers.push(5);
      numbers.push(6);
      console.log(numbers); //원본 수정됨

      //.unshift():배열 가장 앞쪽에 데이터 삽입(나름중요)
      numbers.unshift(0);
      console.log(numbers);

      //.pop():배열의 맨뒤쪽 요소 삭제(push의 반대)
      numbers.pop();
      numbers.pop();
      console.log(numbers);
      
      //.reverse(): 배열의 원본 데이터 뒤집기
      numbers.reverse();
      console.log(numbers);
      
      //.splice(접착)(인덱스,숫자):인덱스 변호부터 해당 숫자만큼 데이터 삭제
      //원본배열이 변경 
      const numbers2=[1,2,3,4];
      const fruits2=['Apple','Banana','Cherry'];
      //numbers2.splice(2,1);// [1,2,4]
      //numbers2.splice(2,2); // [1,2]
      //numbers2.splice(2,0); [1,2,3,4]
      //삽입할수있음
      numbers2.splice(2,0,999)
      console.log(numbers2);

      //문제> fruits 배열 3번째에 'orange'추가
      fruits2.splice(2,0,'Orange');
      console.log(fruits2);
      
      
      
      
       
    </script>
  </body>
</html>
